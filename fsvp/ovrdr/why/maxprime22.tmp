let maxpr_impl =
 fun (n : int) ->
  { (CADUCEUS_3: ge_int(n, (2))) }
  (init:
  try
   begin
     (let i = ref (any_int void) in
     begin
       begin
         (label_1:
         begin
           (i := (let caduceus_6 = n in ((sub_int caduceus_6) (1))));
          while (let caduceus_5 = !i in ((gt_int_ caduceus_5) (0))) do
          { invariant
              (CADUCEUS_5:
              ((lt_int(i, n) and ge_int(i, (0)))
              and (forall k:int.
                   ((gt_int(k, i) and lt_int(k, n)) ->
                    ((not isPrime(k)) or (not isDivisor(k, n)))))))
            variant (CADUCEUS_6 : i) }
           (if (let caduceus_4 = (CADUCEUS_10: ((mod_int_ n) !i)) in
               ((eq_int_ caduceus_4) (0)))
           then
            (let is_prime = ref (1) in
            begin
              (let j = ref (any_int void) in
              begin
                begin
                  (label_2:
                  begin
                    (j := (2));
                   while (let caduceus_3 = !j in ((lt_int_ caduceus_3) !i)) do
                   { invariant
                       (CADUCEUS_7:
                       (((ge_int(j, (2))
                         and (ge_int(i, (2)) -> le_int(j, i)))
                        and (eq_int(i, (1)) -> neq_int(is_prime, (0))))
                       and (neq_int(is_prime, (0))
                           <-> (forall k:int.
                                ((ge_int(k, (2)) and lt_int(k, j)) ->
                                 (not isDivisor(k, i)))))))
                     variant (CADUCEUS_8 : sub_int(i, j)) }
                    (if (let caduceus_2 = (CADUCEUS_9: ((mod_int_ !i) !j)) in
                        ((eq_int_ caduceus_2) (0)))
                    then (is_prime := (0))
                    else void);
                    (j := ((add_int !j) (1)))
                   done
                  end);
                 (if (let caduceus_1 = !is_prime in
                     ((neq_int_ caduceus_1) (0)))
                 then (raise (Return_int !i))
                 else void)
                end
              end)
            end)
           else void);
           (i := ((sub_int !i) (1)))
          done
         end);
        (raise (Return_int (1)))
       end
     end);
    absurd 
   end
   with
   Return_int caduceus_7 ->
   caduceus_7 end)
  { (CADUCEUS_4:
    (((lt_int(result, n) and isDivisor(result, n)) and isPrime(result))
    and (forall i:int.
         ((gt_int(i, result) and lt_int(i, n)) ->
          ((not isPrime(i)) or (not isDivisor(i, n))))))) }

