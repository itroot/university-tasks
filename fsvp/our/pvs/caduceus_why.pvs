caduceus_why: THEORY
BEGIN

  importing why@why

  %% DO NOT EDIT BELOW THIS LINE

  IMPORTING caduceus_why_types0, caduceus_why_types1, caduceus_why_types2

  IMPORTING caduceus_why_decls0, caduceus_why_decls1, caduceus_why_decls2

  IMPORTING caduceus_why_separation2_range1, caduceus_why_separation2,
    caduceus_why_separation1_range, caduceus_why_separation1_range1,
    caduceus_why_separation1, caduceus_why_valid_acc_range,
    caduceus_why_valid_acc, caduceus_why_not_assigns,
    caduceus_why_valid_range, caduceus_why_valid_index, caduceus_why_valid,
    caduceus_why_ge_pointer, caduceus_why_gt_pointer,
    caduceus_why_le_pointer, caduceus_why_lt_pointer

  IMPORTING caduceus_why_axioms0, caduceus_why_axioms1, caduceus_why_axioms2

END caduceus_why

caduceus_why_axioms0: THEORY
BEGIN

  importing why@why
  IMPORTING caduceus_why_types0, caduceus_why_types1, caduceus_why_types2

  IMPORTING caduceus_why_decls0, caduceus_why_decls1, caduceus_why_decls2

  IMPORTING caduceus_why_separation2_range1, caduceus_why_separation2,
    caduceus_why_separation1_range, caduceus_why_separation1_range1,
    caduceus_why_separation1, caduceus_why_valid_acc_range,
    caduceus_why_valid_acc, caduceus_why_not_assigns,
    caduceus_why_valid_range, caduceus_why_valid_index, caduceus_why_valid,
    caduceus_why_ge_pointer, caduceus_why_gt_pointer,
    caduceus_why_le_pointer, caduceus_why_lt_pointer

  %% Why axiom false_not_true
  false_not_true: AXIOM false /= true

  %% Why axiom alloc_extends_refl
  alloc_extends_refl: AXIOM (FORALL (a: alloc_table): alloc_extends(a, a))

  %% Why axiom alloc_extends_trans
  alloc_extends_trans: AXIOM
    (FORALL (a1: alloc_table):
    (FORALL (a2: alloc_table):
    (FORALL (a3: alloc_table):
    (alloc_extends(a1, a2) IMPLIES
    (alloc_extends(a2, a3) IMPLIES alloc_extends(a1, a3))))))

END caduceus_why_axioms0

caduceus_why_axioms1[A1: TYPE]: THEORY
BEGIN

  importing why@why
  IMPORTING caduceus_why_types0, caduceus_why_types1, caduceus_why_types2

  IMPORTING caduceus_why_decls0, caduceus_why_decls1, caduceus_why_decls2

  IMPORTING caduceus_why_separation2_range1, caduceus_why_separation2,
    caduceus_why_separation1_range, caduceus_why_separation1_range1,
    caduceus_why_separation1, caduceus_why_valid_acc_range,
    caduceus_why_valid_acc, caduceus_why_not_assigns,
    caduceus_why_valid_range, caduceus_why_valid_index, caduceus_why_valid,
    caduceus_why_ge_pointer, caduceus_why_gt_pointer,
    caduceus_why_le_pointer, caduceus_why_lt_pointer

  %% Why axiom offset_shift
  offset_shift: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (i: int): offset[A1](shift[A1](p, i)) = offset[A1](p) + i))

  %% Why axiom shift_zero
  shift_zero: AXIOM (FORALL (p: pointer[A1]): shift[A1](p, 0) = p)

  %% Why axiom shift_shift
  shift_shift: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (i: int):
    (FORALL (j: int): shift[A1](shift[A1](p, i), j) = shift[A1](p, i + j))))

  %% Why axiom base_addr_shift
  base_addr_shift: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (i: int): base_addr[A1](shift[A1](p, i)) = base_addr[A1](p)))

  %% Why axiom block_length_shift
  block_length_shift: AXIOM
    (FORALL (a: alloc_table):
    (FORALL (p: pointer[A1]):
    (FORALL (i: int):
    block_length[A1](a, shift[A1](p, i)) = block_length[A1](a, p))))

  %% Why axiom base_addr_block_length
  base_addr_block_length: AXIOM
    (FORALL (a: alloc_table):
    (FORALL (p1: pointer[A1]):
    (FORALL (p2: pointer[A1]):
    (base_addr[A1](p1) = base_addr[A1](p2) IMPLIES
    block_length[A1](a, p1) = block_length[A1](a, p2)))))

  %% Why axiom pointer_pair_1
  pointer_pair_1: AXIOM
    (FORALL (p1: pointer[A1]):
    (FORALL (p2: pointer[A1]):
    (base_addr[A1](p1) = base_addr[A1](p2) AND
    offset[A1](p1) = offset[A1](p2) IMPLIES p1 = p2)))

  %% Why axiom pointer_pair_2
  pointer_pair_2: AXIOM
    (FORALL (p1: pointer[A1]):
    (FORALL (p2: pointer[A1]):
    (p1 = p2 IMPLIES base_addr[A1](p1) = base_addr[A1](p2) AND
    offset[A1](p1) = offset[A1](p2))))

  %% Why axiom neq_base_addr_neq_shift
  neq_base_addr_neq_shift: AXIOM
    (FORALL (p1: pointer[A1]):
    (FORALL (p2: pointer[A1]):
    (FORALL (i: int):
    (FORALL (j: int):
    (base_addr[A1](p1) /= base_addr[A1](p2) IMPLIES shift[A1](p1, i) /=
    shift[A1](p2, j))))))

  %% Why axiom neq_offset_neq_shift
  neq_offset_neq_shift: AXIOM
    (FORALL (p1: pointer[A1]):
    (FORALL (p2: pointer[A1]):
    (FORALL (i: int):
    (FORALL (j: int):
    (offset[A1](p1) + i /= offset[A1](p2) + j IMPLIES shift[A1](p1, i) /=
    shift[A1](p2, j))))))

  %% Why axiom eq_offset_eq_shift
  eq_offset_eq_shift: AXIOM
    (FORALL (p1: pointer[A1]):
    (FORALL (p2: pointer[A1]):
    (FORALL (i: int):
    (FORALL (j: int):
    (base_addr[A1](p1) = base_addr[A1](p2) IMPLIES
    (offset[A1](p1) + i = offset[A1](p2) + j IMPLIES
    shift[A1](p1, i) = shift[A1](p2, j)))))))

  %% Why axiom valid_index_valid_shift
  valid_index_valid_shift: AXIOM
    (FORALL (a: alloc_table):
    (FORALL (p: pointer[A1]):
    (FORALL (i: int):
    (valid_index[A1](a, p, i) IMPLIES valid[A1](a, shift[A1](p, i))))))

  %% Why axiom valid_range_valid_shift
  valid_range_valid_shift: AXIOM
    (FORALL (a: alloc_table):
    (FORALL (p: pointer[A1]):
    (FORALL (i: int):
    (FORALL (j: int):
    (FORALL (k: int):
    (valid_range[A1](a, p, i, j) IMPLIES
    (i <= k AND k <= j IMPLIES valid[A1](a, shift[A1](p, k)))))))))

  %% Why axiom valid_range_valid
  valid_range_valid: AXIOM
    (FORALL (a: alloc_table):
    (FORALL (p: pointer[A1]):
    (FORALL (i: int):
    (FORALL (j: int):
    (valid_range[A1](a, p, i, j) IMPLIES
    (i <= 0 AND 0 <= j IMPLIES valid[A1](a, p)))))))

  %% Why axiom valid_range_valid_index
  valid_range_valid_index: AXIOM
    (FORALL (a: alloc_table):
    (FORALL (p: pointer[A1]):
    (FORALL (i: int):
    (FORALL (j: int):
    (FORALL (k: int):
    (valid_range[A1](a, p, i, j) IMPLIES
    (i <= k AND k <= j IMPLIES valid_index[A1](a, p, k))))))))

  %% Why axiom sub_pointer_def
  sub_pointer_def: AXIOM
    (FORALL (p1: pointer[A1]):
    (FORALL (p2: pointer[A1]):
    (base_addr[A1](p1) = base_addr[A1](p2) IMPLIES
    sub_pointer[A1](p1, p2) = offset[A1](p1) - offset[A1](p2))))

  %% Why axiom pset_empty_intro
  pset_empty_intro: AXIOM
    (FORALL (p: pointer[A1]): not_in_pset[A1](p, pset_empty[A1]))

  %% Why axiom pset_singleton_intro
  pset_singleton_intro: AXIOM
    (FORALL (p1: pointer[A1]):
    (FORALL (p2: pointer[A1]):
    (p1 /= p2 IMPLIES not_in_pset[A1](p1, pset_singleton[A1](p2)))))

  %% Why axiom pset_singleton_elim
  pset_singleton_elim: AXIOM
    (FORALL (p1: pointer[A1]):
    (FORALL (p2: pointer[A1]):
    (not_in_pset[A1](p1, pset_singleton[A1](p2)) IMPLIES p1 /= p2)))

  %% Why axiom not_not_in_singleton
  not_not_in_singleton: AXIOM
    (FORALL (p: pointer[A1]): NOT not_in_pset[A1](p, pset_singleton[A1](p)))

  %% Why axiom pset_union_intro
  pset_union_intro: AXIOM
    (FORALL (l1: pset[A1]):
    (FORALL (l2: pset[A1]):
    (FORALL (p: pointer[A1]):
    (not_in_pset[A1](p, l1) AND not_in_pset[A1](p, l2) IMPLIES
    not_in_pset[A1](p, pset_union[A1](l1, l2))))))

  %% Why axiom pset_union_elim1
  pset_union_elim1: AXIOM
    (FORALL (l1: pset[A1]):
    (FORALL (l2: pset[A1]):
    (FORALL (p: pointer[A1]):
    (not_in_pset[A1](p, pset_union[A1](l1, l2)) IMPLIES
    not_in_pset[A1](p, l1)))))

  %% Why axiom pset_union_elim2
  pset_union_elim2: AXIOM
    (FORALL (l1: pset[A1]):
    (FORALL (l2: pset[A1]):
    (FORALL (p: pointer[A1]):
    (not_in_pset[A1](p, pset_union[A1](l1, l2)) IMPLIES
    not_in_pset[A1](p, l2)))))

  %% Why axiom pset_all_intro
  pset_all_intro: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (l: pset[A1]):
    ((FORALL (p1: pointer[A1]):
     (NOT not_in_pset[A1](p1, l) IMPLIES base_addr[A1](p) /=
     base_addr[A1](p1))) IMPLIES
    not_in_pset[A1](p, pset_all[A1](l)))))

  %% Why axiom pset_all_elim
  pset_all_elim: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (l: pset[A1]):
    (not_in_pset[A1](p, pset_all[A1](l)) IMPLIES
    (FORALL (p1: pointer[A1]):
    (NOT not_in_pset[A1](p1, l) IMPLIES base_addr[A1](p) /=
    base_addr[A1](p1))))))

  %% Why axiom pset_range_intro
  pset_range_intro: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (l: pset[A1]):
    (FORALL (a: int):
    (FORALL (b: int):
    ((FORALL (p1: pointer[A1]): not_in_pset[A1](p1, l) OR
     (FORALL (i: int): (a <= i AND i <= b IMPLIES p /= shift[A1](p1, i)))) IMPLIES
    not_in_pset[A1](p, pset_range[A1](l, a, b)))))))

  %% Why axiom pset_range_elim
  pset_range_elim: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (l: pset[A1]):
    (FORALL (a: int):
    (FORALL (b: int):
    (not_in_pset[A1](p, pset_range[A1](l, a, b)) IMPLIES
    (FORALL (p1: pointer[A1]):
    (NOT not_in_pset[A1](p1, l) IMPLIES
    (FORALL (i: int): (a <= i AND i <= b IMPLIES shift[A1](p1, i) /= p)))))))))

  %% Why axiom pset_range_left_intro
  pset_range_left_intro: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (l: pset[A1]):
    (FORALL (a: int):
    ((FORALL (p1: pointer[A1]): not_in_pset[A1](p1, l) OR
     (FORALL (i: int): (i <= a IMPLIES p /= shift[A1](p1, i)))) IMPLIES
    not_in_pset[A1](p, pset_range_left[A1](l, a))))))

  %% Why axiom pset_range_left_elim
  pset_range_left_elim: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (l: pset[A1]):
    (FORALL (a: int):
    (not_in_pset[A1](p, pset_range_left[A1](l, a)) IMPLIES
    (FORALL (p1: pointer[A1]):
    (NOT not_in_pset[A1](p1, l) IMPLIES
    (FORALL (i: int): (i <= a IMPLIES shift[A1](p1, i) /= p))))))))

  %% Why axiom pset_range_right_intro
  pset_range_right_intro: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (l: pset[A1]):
    (FORALL (a: int):
    ((FORALL (p1: pointer[A1]): not_in_pset[A1](p1, l) OR
     (FORALL (i: int): (a <= i IMPLIES p /= shift[A1](p1, i)))) IMPLIES
    not_in_pset[A1](p, pset_range_right[A1](l, a))))))

  %% Why axiom pset_range_right_elim
  pset_range_right_elim: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (l: pset[A1]):
    (FORALL (a: int):
    (not_in_pset[A1](p, pset_range_right[A1](l, a)) IMPLIES
    (FORALL (p1: pointer[A1]):
    (NOT not_in_pset[A1](p1, l) IMPLIES
    (FORALL (i: int): (a <= i IMPLIES shift[A1](p1, i) /= p))))))))

  %% Why axiom fresh_not_valid
  fresh_not_valid: AXIOM
    (FORALL (a: alloc_table):
    (FORALL (p: pointer[A1]): (fresh[A1](a, p) IMPLIES NOT valid[A1](a, p))))

  %% Why axiom fresh_not_valid_shift
  fresh_not_valid_shift: AXIOM
    (FORALL (a: alloc_table):
    (FORALL (p: pointer[A1]):
    (fresh[A1](a, p) IMPLIES
    (FORALL (i: int): NOT valid[A1](a, shift[A1](p, i))))))

  %% Why axiom alloc_extends_valid
  alloc_extends_valid: AXIOM
    (FORALL (a1: alloc_table):
    (FORALL (a2: alloc_table):
    (alloc_extends(a1, a2) IMPLIES
    (FORALL (q: pointer[A1]): (valid[A1](a1, q) IMPLIES valid[A1](a2, q))))))

  %% Why axiom alloc_extends_valid_index
  alloc_extends_valid_index: AXIOM
    (FORALL (a1: alloc_table):
    (FORALL (a2: alloc_table):
    (alloc_extends(a1, a2) IMPLIES
    (FORALL (q: pointer[A1]):
    (FORALL (i: int):
    (valid_index[A1](a1, q, i) IMPLIES valid_index[A1](a2, q, i)))))))

  %% Why axiom alloc_extends_valid_range
  alloc_extends_valid_range: AXIOM
    (FORALL (a1: alloc_table):
    (FORALL (a2: alloc_table):
    (alloc_extends(a1, a2) IMPLIES
    (FORALL (q: pointer[A1]):
    (FORALL (i: int):
    (FORALL (j: int):
    (valid_range[A1](a1, q, i, j) IMPLIES valid_range[A1](a2, q, i, j))))))))

  %% Why axiom free_stack_heap
  free_stack_heap: AXIOM
    (FORALL (a1: alloc_table):
    (FORALL (a2: alloc_table):
    (FORALL (a3: alloc_table):
    (free_stack(a1, a2, a3) IMPLIES
    (FORALL (p: pointer[A1]):
    (valid[A1](a2, p) IMPLIES (on_heap[A1](a2, p) IMPLIES valid[A1](a3, p))))))))

  %% Why axiom free_stack_stack
  free_stack_stack: AXIOM
    (FORALL (a1: alloc_table):
    (FORALL (a2: alloc_table):
    (FORALL (a3: alloc_table):
    (free_stack(a1, a2, a3) IMPLIES
    (FORALL (p: pointer[A1]):
    (valid[A1](a1, p) IMPLIES (on_stack[A1](a1, p) IMPLIES valid[A1](a3, p))))))))

  %% Why axiom null_not_valid
  null_not_valid: AXIOM (FORALL (a: alloc_table): NOT valid[A1](a, null[A1]))

END caduceus_why_axioms1

caduceus_why_axioms2[A1,A2: TYPE]: THEORY
BEGIN

  importing why@why
  IMPORTING caduceus_why_types0, caduceus_why_types1, caduceus_why_types2

  IMPORTING caduceus_why_decls0, caduceus_why_decls1, caduceus_why_decls2

  IMPORTING caduceus_why_separation2_range1, caduceus_why_separation2,
    caduceus_why_separation1_range, caduceus_why_separation1_range1,
    caduceus_why_separation1, caduceus_why_valid_acc_range,
    caduceus_why_valid_acc, caduceus_why_not_assigns,
    caduceus_why_valid_range, caduceus_why_valid_index, caduceus_why_valid,
    caduceus_why_ge_pointer, caduceus_why_gt_pointer,
    caduceus_why_le_pointer, caduceus_why_lt_pointer

  %% Why axiom acc_upd
  acc_upd: AXIOM
    (FORALL (m: memory[A1, A2]):
    (FORALL (p: pointer[A2]):
    (FORALL (a: A1): acc[A1, A2](upd[A1, A2](m, p, a), p) = a)))

  %% Why axiom acc_upd_neq
  acc_upd_neq: AXIOM
    (FORALL (m: memory[A1, A2]):
    (FORALL (p1: pointer[A2]):
    (FORALL (p2: pointer[A2]):
    (FORALL (a: A1):
    (p1 /= p2 IMPLIES
    acc[A1, A2](upd[A1, A2](m, p1, a), p2) = acc[A1, A2](m, p2))))))

  %% Why axiom pset_star_intro
  pset_star_intro: AXIOM
    (FORALL (l: pset[A1]):
    (FORALL (m: memory[pointer[A2], A1]):
    (FORALL (p: pointer[A2]):
    ((FORALL (p1: pointer[A1]):
     (p = acc[pointer[A2], A1](m, p1) IMPLIES not_in_pset[A1](p1, l))) IMPLIES
    not_in_pset[A2](p, pset_star[A2, A1](l, m))))))

  %% Why axiom pset_star_elim
  pset_star_elim: AXIOM
    (FORALL (l: pset[A1]):
    (FORALL (m: memory[pointer[A2], A1]):
    (FORALL (p: pointer[A2]):
    (not_in_pset[A2](p, pset_star[A2, A1](l, m)) IMPLIES
    (FORALL (p1: pointer[A1]):
    (p = acc[pointer[A2], A1](m, p1) IMPLIES not_in_pset[A1](p1, l)))))))

  %% Why axiom pset_acc_all_intro
  pset_acc_all_intro: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (l: pset[A2]):
    (FORALL (m: memory[pointer[A1], A2]):
    ((FORALL (p1: pointer[A2]):
     (NOT not_in_pset[A2](p1, l) IMPLIES
     (FORALL (i: int): p /= acc[pointer[A1], A2](m, shift[A2](p1, i))))) IMPLIES
    not_in_pset[A1](p, pset_acc_all[A1, A2](l, m))))))

  %% Why axiom pset_acc_all_elim
  pset_acc_all_elim: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (l: pset[A2]):
    (FORALL (m: memory[pointer[A1], A2]):
    (not_in_pset[A1](p, pset_acc_all[A1, A2](l, m)) IMPLIES
    (FORALL (p1: pointer[A2]):
    (NOT not_in_pset[A2](p1, l) IMPLIES
    (FORALL (i: int): acc[pointer[A1], A2](m, shift[A2](p1, i)) /= p)))))))

  %% Why axiom pset_acc_range_intro
  pset_acc_range_intro: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (l: pset[A2]):
    (FORALL (m: memory[pointer[A1], A2]):
    (FORALL (a: int):
    (FORALL (b: int):
    ((FORALL (p1: pointer[A2]):
     (NOT not_in_pset[A2](p1, l) IMPLIES
     (FORALL (i: int):
     (a <= i AND i <= b IMPLIES p /= acc[pointer[A1],
     A2](m, shift[A2](p1, i)))))) IMPLIES
    not_in_pset[A1](p, pset_acc_range[A1, A2](l, m, a, b))))))))

  %% Why axiom pset_acc_range_elim
  pset_acc_range_elim: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (l: pset[A2]):
    (FORALL (m: memory[pointer[A1], A2]):
    (FORALL (a: int):
    (FORALL (b: int):
    (not_in_pset[A1](p, pset_acc_range[A1, A2](l, m, a, b)) IMPLIES
    (FORALL (p1: pointer[A2]):
    (NOT not_in_pset[A2](p1, l) IMPLIES
    (FORALL (i: int):
    (a <= i AND i <= b IMPLIES acc[pointer[A1], A2](m, shift[A2](p1, i)) /=
    p))))))))))

  %% Why axiom pset_acc_range_left_intro
  pset_acc_range_left_intro: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (l: pset[A2]):
    (FORALL (m: memory[pointer[A1], A2]):
    (FORALL (a: int):
    ((FORALL (p1: pointer[A2]):
     (NOT not_in_pset[A2](p1, l) IMPLIES
     (FORALL (i: int):
     (i <= a IMPLIES p /= acc[pointer[A1], A2](m, shift[A2](p1, i)))))) IMPLIES
    not_in_pset[A1](p, pset_acc_range_left[A1, A2](l, m, a)))))))

  %% Why axiom pset_acc_range_left_elim
  pset_acc_range_left_elim: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (l: pset[A2]):
    (FORALL (m: memory[pointer[A1], A2]):
    (FORALL (a: int):
    (not_in_pset[A1](p, pset_acc_range_left[A1, A2](l, m, a)) IMPLIES
    (FORALL (p1: pointer[A2]):
    (NOT not_in_pset[A2](p1, l) IMPLIES
    (FORALL (i: int):
    (i <= a IMPLIES acc[pointer[A1], A2](m, shift[A2](p1, i)) /= p)))))))))

  %% Why axiom pset_acc_range_right_intro
  pset_acc_range_right_intro: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (l: pset[A2]):
    (FORALL (m: memory[pointer[A1], A2]):
    (FORALL (a: int):
    ((FORALL (p1: pointer[A2]):
     (NOT not_in_pset[A2](p1, l) IMPLIES
     (FORALL (i: int):
     (a <= i IMPLIES p /= acc[pointer[A1], A2](m, shift[A2](p1, i)))))) IMPLIES
    not_in_pset[A1](p, pset_acc_range_right[A1, A2](l, m, a)))))))

  %% Why axiom pset_acc_range_right_elim
  pset_acc_range_right_elim: AXIOM
    (FORALL (p: pointer[A1]):
    (FORALL (l: pset[A2]):
    (FORALL (m: memory[pointer[A1], A2]):
    (FORALL (a: int):
    (not_in_pset[A1](p, pset_acc_range_right[A1, A2](l, m, a)) IMPLIES
    (FORALL (p1: pointer[A2]):
    (NOT not_in_pset[A2](p1, l) IMPLIES
    (FORALL (i: int):
    (a <= i IMPLIES acc[pointer[A1], A2](m, shift[A2](p1, i)) /= p)))))))))

  %% Why axiom not_assigns_trans
  not_assigns_trans: AXIOM
    (FORALL (a: alloc_table):
    (FORALL (l: pset[A1]):
    (FORALL (m1: memory[A2, A1]):
    (FORALL (m2: memory[A2, A1]):
    (FORALL (m3: memory[A2, A1]):
    (not_assigns[A2, A1](a, m1, m2, l) IMPLIES
    (not_assigns[A2, A1](a, m2, m3, l) IMPLIES not_assigns[A2,
    A1](a, m1, m3, l))))))))

  %% Why axiom not_assigns_refl
  not_assigns_refl: AXIOM
    (FORALL (a: alloc_table):
    (FORALL (l: pset[A1]):
    (FORALL (m: memory[A2, A1]): not_assigns[A2, A1](a, m, m, l))))

  %% Why axiom valid_acc_range_valid
  valid_acc_range_valid: AXIOM
    (FORALL (m1: memory[pointer[A1], A2]):
    (FORALL (size: int):
    (FORALL (p: pointer[A2]):
    (FORALL (a: alloc_table):
    (valid_acc_range[A1, A2](m1, size) IMPLIES
    (valid[A2](a, p) IMPLIES valid[A1](a, acc[pointer[A1], A2](m1, p))))))))

END caduceus_why_axioms2

caduceus_why_lt_pointer[A1: TYPE]: THEORY
BEGIN

  importing why@why
  IMPORTING caduceus_why_types0, caduceus_why_types1, caduceus_why_types2

  IMPORTING caduceus_why_decls0, caduceus_why_decls1, caduceus_why_decls2

  lt_pointer(p1:pointer[A1], p2:pointer[A1]) : bool =
    base_addr[A1](p1) = base_addr[A1](p2) AND offset[A1](p1) < offset[A1](p2)

END caduceus_why_lt_pointer

caduceus_why_le_pointer[A1: TYPE]: THEORY
BEGIN

  importing why@why
  IMPORTING caduceus_why_types0, caduceus_why_types1, caduceus_why_types2

  IMPORTING caduceus_why_decls0, caduceus_why_decls1, caduceus_why_decls2

  IMPORTING caduceus_why_lt_pointer

  le_pointer(p1:pointer[A1], p2:pointer[A1]) : bool =
    base_addr[A1](p1) = base_addr[A1](p2) AND
    offset[A1](p1) <= offset[A1](p2)

END caduceus_why_le_pointer

caduceus_why_gt_pointer[A1: TYPE]: THEORY
BEGIN

  importing why@why
  IMPORTING caduceus_why_types0, caduceus_why_types1, caduceus_why_types2

  IMPORTING caduceus_why_decls0, caduceus_why_decls1, caduceus_why_decls2

  IMPORTING caduceus_why_le_pointer, caduceus_why_lt_pointer

  gt_pointer(p1:pointer[A1], p2:pointer[A1]) : bool =
    base_addr[A1](p1) = base_addr[A1](p2) AND offset[A1](p1) > offset[A1](p2)

END caduceus_why_gt_pointer

caduceus_why_ge_pointer[A1: TYPE]: THEORY
BEGIN

  importing why@why
  IMPORTING caduceus_why_types0, caduceus_why_types1, caduceus_why_types2

  IMPORTING caduceus_why_decls0, caduceus_why_decls1, caduceus_why_decls2

  IMPORTING caduceus_why_gt_pointer, caduceus_why_le_pointer,
    caduceus_why_lt_pointer

  ge_pointer(p1:pointer[A1], p2:pointer[A1]) : bool =
    base_addr[A1](p1) = base_addr[A1](p2) AND
    offset[A1](p1) >= offset[A1](p2)

END caduceus_why_ge_pointer

caduceus_why_valid[A1: TYPE]: THEORY
BEGIN

  importing why@why
  IMPORTING caduceus_why_types0, caduceus_why_types1, caduceus_why_types2

  IMPORTING caduceus_why_decls0, caduceus_why_decls1, caduceus_why_decls2

  IMPORTING caduceus_why_ge_pointer, caduceus_why_gt_pointer,
    caduceus_why_le_pointer, caduceus_why_lt_pointer

  valid(a:alloc_table, p:pointer[A1]) : bool =
    0 <= offset[A1](p) AND offset[A1](p) < block_length[A1](a, p)

END caduceus_why_valid

caduceus_why_valid_index[A1: TYPE]: THEORY
BEGIN

  importing why@why
  IMPORTING caduceus_why_types0, caduceus_why_types1, caduceus_why_types2

  IMPORTING caduceus_why_decls0, caduceus_why_decls1, caduceus_why_decls2

  IMPORTING caduceus_why_valid, caduceus_why_ge_pointer,
    caduceus_why_gt_pointer, caduceus_why_le_pointer, caduceus_why_lt_pointer

  valid_index(a:alloc_table, p:pointer[A1], i:int) : bool =
    0 <= offset[A1](p) + i AND offset[A1](p) + i < block_length[A1](a, p)

END caduceus_why_valid_index

caduceus_why_valid_range[A1: TYPE]: THEORY
BEGIN

  importing why@why
  IMPORTING caduceus_why_types0, caduceus_why_types1, caduceus_why_types2

  IMPORTING caduceus_why_decls0, caduceus_why_decls1, caduceus_why_decls2

  IMPORTING caduceus_why_valid_index, caduceus_why_valid,
    caduceus_why_ge_pointer, caduceus_why_gt_pointer,
    caduceus_why_le_pointer, caduceus_why_lt_pointer

  valid_range(a:alloc_table, p:pointer[A1], i:int, j:int) : bool =
    0 <= offset[A1](p) + i AND offset[A1](p) + j < block_length[A1](a, p)

END caduceus_why_valid_range

caduceus_why_not_assigns[A1,A2: TYPE]: THEORY
BEGIN

  importing why@why
  IMPORTING caduceus_why_types0, caduceus_why_types1, caduceus_why_types2

  IMPORTING caduceus_why_decls0, caduceus_why_decls1, caduceus_why_decls2

  IMPORTING caduceus_why_valid_range, caduceus_why_valid_index,
    caduceus_why_valid, caduceus_why_ge_pointer, caduceus_why_gt_pointer,
    caduceus_why_le_pointer, caduceus_why_lt_pointer

  not_assigns(a:alloc_table, m1:memory[A1, A2], m2:memory[A1, A2], l:pset[A2]) : bool =
    (FORALL (p: pointer[A2]):
    (valid[A2](a, p) IMPLIES
    (not_in_pset[A2](p, l) IMPLIES acc[A1, A2](m2, p) = acc[A1, A2](m1, p))))

END caduceus_why_not_assigns

caduceus_why_valid_acc[A1,A2: TYPE]: THEORY
BEGIN

  importing why@why
  IMPORTING caduceus_why_types0, caduceus_why_types1, caduceus_why_types2

  IMPORTING caduceus_why_decls0, caduceus_why_decls1, caduceus_why_decls2

  IMPORTING caduceus_why_not_assigns, caduceus_why_valid_range,
    caduceus_why_valid_index, caduceus_why_valid, caduceus_why_ge_pointer,
    caduceus_why_gt_pointer, caduceus_why_le_pointer, caduceus_why_lt_pointer

  valid_acc(m1:memory[pointer[A1], A2]) : bool =
    (FORALL (p: pointer[A2]):
    (FORALL (a: alloc_table):
    (valid[A2](a, p) IMPLIES valid[A1](a, acc[pointer[A1], A2](m1, p)))))

END caduceus_why_valid_acc

caduceus_why_valid_acc_range[A1,A2: TYPE]: THEORY
BEGIN

  importing why@why
  IMPORTING caduceus_why_types0, caduceus_why_types1, caduceus_why_types2

  IMPORTING caduceus_why_decls0, caduceus_why_decls1, caduceus_why_decls2

  IMPORTING caduceus_why_valid_acc, caduceus_why_not_assigns,
    caduceus_why_valid_range, caduceus_why_valid_index, caduceus_why_valid,
    caduceus_why_ge_pointer, caduceus_why_gt_pointer,
    caduceus_why_le_pointer, caduceus_why_lt_pointer

  valid_acc_range(m1:memory[pointer[A1], A2], size:int) : bool =
    (FORALL (p: pointer[A2]):
    (FORALL (a: alloc_table):
    (valid[A2](a, p) IMPLIES
    valid_range[A1](a, acc[pointer[A1], A2](m1, p), 0, size - 1))))

END caduceus_why_valid_acc_range

caduceus_why_separation1[A1,A2: TYPE]: THEORY
BEGIN

  importing why@why
  IMPORTING caduceus_why_types0, caduceus_why_types1, caduceus_why_types2

  IMPORTING caduceus_why_decls0, caduceus_why_decls1, caduceus_why_decls2

  IMPORTING caduceus_why_valid_acc_range, caduceus_why_valid_acc,
    caduceus_why_not_assigns, caduceus_why_valid_range,
    caduceus_why_valid_index, caduceus_why_valid, caduceus_why_ge_pointer,
    caduceus_why_gt_pointer, caduceus_why_le_pointer, caduceus_why_lt_pointer

  separation1(m1:memory[pointer[A1], A2], m2:memory[pointer[A1], A2]) : bool =
    (FORALL (p: pointer[A2]):
    (FORALL (a: alloc_table):
    (valid[A2](a, p) IMPLIES base_addr[A1](acc[pointer[A1], A2](m1, p)) /=
    base_addr[A1](acc[pointer[A1], A2](m2, p)))))

END caduceus_why_separation1

caduceus_why_separation1_range1[A1,A2: TYPE]: THEORY
BEGIN

  importing why@why
  IMPORTING caduceus_why_types0, caduceus_why_types1, caduceus_why_types2

  IMPORTING caduceus_why_decls0, caduceus_why_decls1, caduceus_why_decls2

  IMPORTING caduceus_why_separation1, caduceus_why_valid_acc_range,
    caduceus_why_valid_acc, caduceus_why_not_assigns,
    caduceus_why_valid_range, caduceus_why_valid_index, caduceus_why_valid,
    caduceus_why_ge_pointer, caduceus_why_gt_pointer,
    caduceus_why_le_pointer, caduceus_why_lt_pointer

  separation1_range1(m1:memory[pointer[A1], A2], m2:memory[pointer[A1], A2],
                     size:int) : bool =
    (FORALL (p: pointer[A2]):
    (FORALL (a: alloc_table):
    (valid[A2](a, p) IMPLIES
    (FORALL (i1: int):
    (FORALL (i2: int):
    (0 <= i1 AND i1 < size IMPLIES
    (0 <= i2 AND i2 < size IMPLIES
    base_addr[A1](acc[pointer[A1], A2](m1, shift[A2](p, i1))) /=
    base_addr[A1](acc[pointer[A1], A2](m2, shift[A2](p, i2))))))))))

END caduceus_why_separation1_range1

caduceus_why_separation1_range[A1,A2: TYPE]: THEORY
BEGIN

  importing why@why
  IMPORTING caduceus_why_types0, caduceus_why_types1, caduceus_why_types2

  IMPORTING caduceus_why_decls0, caduceus_why_decls1, caduceus_why_decls2

  IMPORTING caduceus_why_separation1_range1, caduceus_why_separation1,
    caduceus_why_valid_acc_range, caduceus_why_valid_acc,
    caduceus_why_not_assigns, caduceus_why_valid_range,
    caduceus_why_valid_index, caduceus_why_valid, caduceus_why_ge_pointer,
    caduceus_why_gt_pointer, caduceus_why_le_pointer, caduceus_why_lt_pointer

  separation1_range(m:memory[pointer[A1], A2], size:int) : bool =
    (FORALL (p: pointer[A2]):
    (FORALL (a: alloc_table):
    (valid[A2](a, p) IMPLIES
    (FORALL (i1: int):
    (0 <= i1 AND i1 < size IMPLIES
    base_addr[A1](acc[pointer[A1], A2](m, shift[A2](p, i1))) /=
    base_addr[A1](acc[pointer[A1], A2](m, p)))))))

END caduceus_why_separation1_range

caduceus_why_separation2[A1,A2: TYPE]: THEORY
BEGIN

  importing why@why
  IMPORTING caduceus_why_types0, caduceus_why_types1, caduceus_why_types2

  IMPORTING caduceus_why_decls0, caduceus_why_decls1, caduceus_why_decls2

  IMPORTING caduceus_why_separation1_range, caduceus_why_separation1_range1,
    caduceus_why_separation1, caduceus_why_valid_acc_range,
    caduceus_why_valid_acc, caduceus_why_not_assigns,
    caduceus_why_valid_range, caduceus_why_valid_index, caduceus_why_valid,
    caduceus_why_ge_pointer, caduceus_why_gt_pointer,
    caduceus_why_le_pointer, caduceus_why_lt_pointer

  separation2(m1:memory[pointer[A1], A2], m2:memory[pointer[A1], A2]) : bool =
    (FORALL (p1: pointer[A2]):
    (FORALL (p2: pointer[A2]):
    (p1 /= p2 IMPLIES base_addr[A1](acc[pointer[A1], A2](m1, p1)) /=
    base_addr[A1](acc[pointer[A1], A2](m2, p2)))))

END caduceus_why_separation2

caduceus_why_separation2_range1[A1,A2: TYPE]: THEORY
BEGIN

  importing why@why
  IMPORTING caduceus_why_types0, caduceus_why_types1, caduceus_why_types2

  IMPORTING caduceus_why_decls0, caduceus_why_decls1, caduceus_why_decls2

  IMPORTING caduceus_why_separation2, caduceus_why_separation1_range,
    caduceus_why_separation1_range1, caduceus_why_separation1,
    caduceus_why_valid_acc_range, caduceus_why_valid_acc,
    caduceus_why_not_assigns, caduceus_why_valid_range,
    caduceus_why_valid_index, caduceus_why_valid, caduceus_why_ge_pointer,
    caduceus_why_gt_pointer, caduceus_why_le_pointer, caduceus_why_lt_pointer

  separation2_range1(m1:memory[pointer[A1], A2], m2:memory[pointer[A1], A2],
                     size:int) : bool =
    (FORALL (p: pointer[A2]):
    (FORALL (q: pointer[A2]):
    (FORALL (a: alloc_table):
    (FORALL (i: int):
    (0 <= i AND i < size IMPLIES
    base_addr[A1](acc[pointer[A1], A2](m1, shift[A2](p, i))) /=
    base_addr[A1](acc[pointer[A1], A2](m2, q)))))))

END caduceus_why_separation2_range1

caduceus_why_decls0: THEORY
BEGIN

  importing why@why
  IMPORTING caduceus_why_types0, caduceus_why_types1, caduceus_why_types2

  %% Why logic bw_compl
  bw_compl: [int -> int]

  %% Why logic bw_and
  bw_and: [int, int -> int]

  %% Why logic bw_xor
  bw_xor: [int, int -> int]

  %% Why logic bw_or
  bw_or: [int, int -> int]

  %% Why logic lsl
  lsl: [int, int -> int]

  %% Why logic lsr
  lsr: [int, int -> int]

  %% Why logic alloc_extends
  alloc_extends: [alloc_table, alloc_table -> bool]

  %% Why logic free_stack
  free_stack: [alloc_table, alloc_table, alloc_table -> bool]

END caduceus_why_decls0

caduceus_why_decls1[A1: TYPE]: THEORY
BEGIN

  importing why@why
  IMPORTING caduceus_why_types0, caduceus_why_types1, caduceus_why_types2

  %% Why logic block_length
  block_length: [alloc_table, pointer[A1] -> int]

  %% Why logic base_addr
  base_addr: [pointer[A1] -> addr[A1]]

  %% Why logic offset
  offset: [pointer[A1] -> int]

  %% Why logic shift
  shift: [pointer[A1], int -> pointer[A1]]

  %% Why logic sub_pointer
  sub_pointer: [pointer[A1], pointer[A1] -> int]

  %% Why logic pset_empty
  pset_empty: pset[A1]

  %% Why logic pset_singleton
  pset_singleton: [pointer[A1] -> pset[A1]]

  %% Why logic pset_all
  pset_all: [pset[A1] -> pset[A1]]

  %% Why logic pset_range
  pset_range: [pset[A1], int, int -> pset[A1]]

  %% Why logic pset_range_left
  pset_range_left: [pset[A1], int -> pset[A1]]

  %% Why logic pset_range_right
  pset_range_right: [pset[A1], int -> pset[A1]]

  %% Why logic pset_union
  pset_union: [pset[A1], pset[A1] -> pset[A1]]

  %% Why logic not_in_pset
  not_in_pset: [pointer[A1], pset[A1] -> bool]

  %% Why logic on_heap
  on_heap: [alloc_table, pointer[A1] -> bool]

  %% Why logic on_stack
  on_stack: [alloc_table, pointer[A1] -> bool]

  %% Why logic fresh
  fresh: [alloc_table, pointer[A1] -> bool]

  %% Why logic null
  null: pointer[A1]

END caduceus_why_decls1

caduceus_why_decls2[A1,A2: TYPE]: THEORY
BEGIN

  importing why@why
  IMPORTING caduceus_why_types0, caduceus_why_types1, caduceus_why_types2

  %% Why logic acc
  acc: [memory[A1, A2], pointer[A2] -> A1]

  %% Why logic upd
  upd: [memory[A1, A2], pointer[A2], A1 -> memory[A1, A2]]

  %% Why logic pset_star
  pset_star: [pset[A2], memory[pointer[A1], A2] -> pset[A1]]

  %% Why logic pset_acc_all
  pset_acc_all: [pset[A2], memory[pointer[A1], A2] -> pset[A1]]

  %% Why logic pset_acc_range
  pset_acc_range: [pset[A2], memory[pointer[A1], A2], int, int -> pset[A1]]

  %% Why logic pset_acc_range_left
  pset_acc_range_left: [pset[A2], memory[pointer[A1], A2], int -> pset[A1]]

  %% Why logic pset_acc_range_right
  pset_acc_range_right: [pset[A2], memory[pointer[A1], A2], int -> pset[A1]]

END caduceus_why_decls2

caduceus_why_types0: THEORY
BEGIN

  importing why@why
  alloc_table: TYPE+;

END caduceus_why_types0

caduceus_why_types1[A1: TYPE]: THEORY
BEGIN

  importing why@why
  pointer: TYPE+;

  addr: TYPE+;

  pset: TYPE+;

END caduceus_why_types1

caduceus_why_types2[A1,A2: TYPE]: THEORY
BEGIN

  importing why@why
  memory: TYPE+;

END caduceus_why_types2

